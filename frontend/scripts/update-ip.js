const fs = require("fs");
const path = require("path");
const os = require("os");
const http = require("http");
const https = require("https");

function joinUrl(baseUrl, urlPath) {
  if (!baseUrl) return urlPath;
  const trimmedBase = baseUrl.endsWith("/") ? baseUrl.slice(0, -1) : baseUrl;
  const trimmedPath = urlPath.startsWith("/") ? urlPath : `/${urlPath}`;
  return `${trimmedBase}${trimmedPath}`;
}

function probeHealth(baseUrl, timeoutMs = 800) {
  return new Promise((resolve) => {
    try {
      const healthUrl = joinUrl(baseUrl, "/api/health");
      const client = healthUrl.startsWith("https:") ? https : http;
      const req = client.get(
        healthUrl,
        {
          timeout: timeoutMs,
          headers: {
            Accept: "application/json",
          },
        },
        (res) => {
          res.resume();
          resolve(res.statusCode >= 200 && res.statusCode < 500);
        },
      );
      req.on("timeout", () => {
        req.destroy(new Error("timeout"));
      });
      req.on("error", () => resolve(false));
    } catch {
      resolve(false);
    }
  });
}

function getLocalIpAddress() {
  const interfaces = os.networkInterfaces();
  const allAddresses = [];

  // Collect all valid IPv4 addresses
  for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
      if (iface.family === "IPv4" && !iface.internal) {
        allAddresses.push({ name, address: iface.address });
      }
    }
  }

  // Priority 1: en0 (standard Mac WiFi)
  const en0 = allAddresses.find((idx) => idx.name === "en0");
  if (en0) return en0.address;

  // Priority 2: 192.168.0.x (common home WiFi subnet)
  const zeroSubnet = allAddresses.find((idx) =>
    idx.address.startsWith("192.168.0."),
  );
  if (zeroSubnet) return zeroSubnet.address;

  // Priority 3: First available
  if (allAddresses.length > 0) return allAddresses[0].address;

  return "localhost";
}

const envPath = path.resolve(__dirname, "../.env");
const localIp = getLocalIpAddress();

// Prefer the backend-reported URL/IP if available (keeps frontend in sync)
let backendUrlFromFile = null;

// Try to read port from backend_port.json (generated by backend)
let port = process.env.EXPO_PUBLIC_BACKEND_PORT || "8001";
let backendIpFromFile = null;
try {
  const backendPortPath = path.resolve(__dirname, "../../backend_port.json");
  if (fs.existsSync(backendPortPath)) {
    const portData = JSON.parse(fs.readFileSync(backendPortPath, "utf8"));
    if (
      portData &&
      typeof portData.url === "string" &&
      portData.url.length > 0
    ) {
      backendUrlFromFile = portData.url;
      console.log(
        `Detected Backend URL from backend_port.json: ${backendUrlFromFile}`,
      );
    } else if (
      portData &&
      typeof portData.ip === "string" &&
      portData.ip.length > 0
    ) {
      backendIpFromFile = portData.ip;
      backendUrlFromFile = `http://${portData.ip}:${portData.port || port}`;
      console.log(
        `Detected Backend IP from backend_port.json: ${backendUrlFromFile}`,
      );
    }
    if (portData && portData.port) {
      port = portData.port.toString();
      console.log(`Detected Dynamic Backend Port: ${port}`);
    }
  }
} catch (e) {
  console.log("Could not read backend_port.json, using default port");
}

console.log(`Detected Local IP: ${localIp}`);

async function main() {
  try {
    let envContent = fs.readFileSync(envPath, "utf8");

    const ipForFallback = backendIpFromFile || localIp;
    const candidateUrls = [];
    if (backendUrlFromFile) candidateUrls.push(backendUrlFromFile);
    candidateUrls.push(`http://${ipForFallback}:8001`);
    candidateUrls.push(`http://${ipForFallback}:${port}`);

    // De-dupe while preserving order
    const uniqueCandidates = [...new Set(candidateUrls.filter(Boolean))];

    let computedBackendUrl = backendUrlFromFile || `http://${localIp}:${port}`;
    for (const candidate of uniqueCandidates) {
      // If backend isn't running yet, don't block; we'll fall back below.
      // But if a candidate IS reachable, prefer it.
      // eslint-disable-next-line no-await-in-loop
      const ok = await probeHealth(candidate);
      if (ok) {
        computedBackendUrl = candidate;
        break;
      }
    }

    // Regex to replace EXPO_PUBLIC_BACKEND_URL
    const frontendUrlRegex = /^EXPO_PUBLIC_BACKEND_URL=.*$/m;
    const newFrontendUrlLine = `EXPO_PUBLIC_BACKEND_URL=${computedBackendUrl}`;

    if (frontendUrlRegex.test(envContent)) {
      envContent = envContent.replace(frontendUrlRegex, newFrontendUrlLine);
      console.log(`Updated EXPO_PUBLIC_BACKEND_URL to ${newFrontendUrlLine}`);
    } else {
      envContent += `\n${newFrontendUrlLine}`;
      console.log(`Added EXPO_PUBLIC_BACKEND_URL: ${newFrontendUrlLine}`);
    }

    fs.writeFileSync(envPath, envContent);
    console.log("Successfully updated .env file");
  } catch (error) {
    console.error("Error updating .env file:", error);
    process.exit(1);
  }
}

main();
